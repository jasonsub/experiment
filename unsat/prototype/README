Steps as of 03/31/2015:

1. cnf2poly: only 3-SAT

2. copy & paste GB shell: get test.sing

3. run: (uncomment "quit;") get a log file
Backtrack from "1", list all GB polys related.

4. run again: For all newly generated polys, count all polys involved when doing reduction
Example below: suppose we find poly in GB G0[66] (newly) generated by G0[1] and G0[17]
> sp = my_spoly(G0[1], G0[17]);
> sp;  // this is for checking spoly is not an weird stuff
> G = G0[1..65];  // When computing GB, G0[66] is only reduced by polys generated earlier than it: 1~65
> multidiv_q(sp, G);  // this will give u a list, which is in the original order how G0[66] was reduced
If you want to verify more and make sure no typo disaster, you can do:
> multidiv(sp, G) - G0[66];
This should be "0" if you honestly repeat the reduction w/o any typos

5. use dup.o: get core index list
You will get a DAG on sheet, with only root indices left. Now use my nonredundant indices recorder:
$ ./dup.o
Type in thoses numbers one by one, and end with any non-number symbol. It will remove duplicates and sort.
I don't think u need to modify duplicate_remove.cpp

6. slim_cnf: create extracted-core CNF file out of original CNF
copy & paste output from dup.o

7. check core unsatisfiability with SAT solver
