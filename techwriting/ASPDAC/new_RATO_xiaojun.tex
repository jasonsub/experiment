\section{Improvement on RATO Based Abstraction}
A lexicographic order defined by following relation $>_{r}$: "circuit variables ordered reverse topologically" $>$ 
"word-level output" $>$ "word-level inputs" is called the \emph{Refined Abstraction Term Order (RATO)}. Main procedure
of abstraction based on RATO proposed by T. Pruss(cite Tim here)\cite{TimDAC} is: first, in ideal generated by
gates information polynomials and word-level variable definition polynomials, find the unique pair of polynomial
generators with leading monomials not relatively prime to each other; then, compute their specification polynomial
using definition 
$$Spoly(f_w,f_g) = \frac{LCM}{lt(f_w)}\cdot f_w - \frac{LCM}{lt(f_g)}\cdot f_g$$
where $LCM$ is least common multiple of $lm(f_w)$ and $lm(f_g)$, and $lt$ denotes the leading term;
last, reduce $Spoly$ with ideal $J_{ckt}+J_0$, it is possible that the remainder will be canonical polynomial
function of the circuit. This technique
cannot obviate the need of Gr\"obner basis computation under some situations, as discussed
in section \ref{sec:prework}. To better illustrate those limitations, we apply RATO on 5-bit RH-SMPO in Fig.\ref{fig:RHmulti}.

\begin{Example}
\label{ex:newRATO}
Variable order under RATO is:
\begin{align}
&\{r_0',r_1',r_2',r_3',r_4'\}>\{r_0,r_1,r_2,r_3,r_4\}\nonumber\\
&>\{e_0,e_3,e_4\},\{d_0,d_1,d_2\},\{c_1,c_2,c_3,c_4\}\nonumber\\
&>\{a_0,a_1,a_2,a_3,a_4,b_0,b_1,b_2,b_3,b_4\}>R'>R>\{A,B\}\nonumber
\end{align}
Search among all generators of $J_{ckt}$ from Ex.\ref{ex:RHSMPO} using RATO, we find a pair of polynomials whose leading 
monomials are not relatively prime:
$(f_w,f_g), f_w = r_0'+r_4+e_0, f_g =r_0'\alpha^5+r_1'\alpha^{10}+r_2'\alpha^{20}+r_3'\alpha^9+r_4'\alpha^{18} + R'$.
We calculate $Spoly$ can reduce it by $J_{ckt}+J_0$:
\begin{align}
&Spoly(f_w,f_g) \xrightarrow{J_{ckt}+J_0}_{+}\nonumber\\
&(\alpha^3+\alpha^2+\alpha) r_1+(\alpha^4+\alpha^3+\alpha^2) r_2+(\alpha^2+\alpha) r_3+(\alpha) r_4\nonumber\\
&+(\alpha^3+\alpha^2) a_1 b_1+(\alpha^4+\alpha^3+\alpha^2+\alpha) a_1 b_2+(\alpha^2+\alpha) a_1 b_3\nonumber\\
&+(\alpha^2+1) a_1 b_4+(\alpha^4+1) a_1 B+(\alpha^4+\alpha) a_2 b_1+(\alpha^4+\alpha^3+\alpha) a_2 b_2\nonumber\\
&+(\alpha^3+1) a_2 b_3+(\alpha^3+\alpha^2+1) a_2 b_4+(\alpha^3+\alpha^2) a_2 B+(\alpha^2+\alpha) a_3 b_1\nonumber\\
&+(\alpha^3+1) a_3 b_2+(\alpha+1) a_3 b_3+(\alpha^4+\alpha^2+\alpha) a_3 b_4\nonumber\\
&+(\alpha^4+\alpha^3+\alpha) a_3 B+(\alpha^3+1) a_4 b_1+a_4 b_2+(\alpha^4+\alpha^2+\alpha) a_4 b_3\nonumber\\
&+(\alpha^4+\alpha^3+1) a_4 b_4+(\alpha^2+\alpha) a_4 B+(\alpha^4+1) b_1 A+(\alpha^3+\alpha^2) b_2 A\nonumber\\
&+(\alpha^4+\alpha^3+\alpha) b_3 A+(\alpha^2+\alpha) b_4 A+(\alpha^4+\alpha^2+\alpha+1) R'+R+A B\nonumber
\end{align}
\end{Example}
Above example indicates that RATO based abstraction on 5-bit RH-SMPO will result a remainder contains both
bit-level variables and word-level variables, and the number of remaining variables is still large such that
Gr\"obner basis computation will be inefficient.

\subsection{Improved RATO based Abstraction}
The remainder from \emph{Spoly} reduction contains some bit-level variables, and our objective is to compute
a polynomial contains only word-level variables (such as $R'+\mathcal{F}(A,B)$). One possible solution to
this problem is to replace bit-level variable monomials by equivalent polynomials that only contain word-level
variables, e.g. $a_i = \mathcal{G}(A), r_j = \mathcal{H}(R)$. In this section a Gaussian-elimination-fashion 
approach is introduced to compute corresponding $\mathcal{G}(A),\mathcal{H}(R)$ efficiently.

\begin{Example}
{\bf Objective}:\ Compute polynomial $a_i + \mathcal{G}_i(A)$ from $f_0 = a_0\alpha^5+a_1\alpha^{10}+a_2\alpha^{20}+a_3\alpha^9+a_4\alpha^{18}+A
 = g_0 + A$.

First, compute $f_0^2= a_0\alpha^{10}+a_1\alpha^{20}+a_2\alpha^{9}+a_3\alpha^{18}+a_4\alpha^{5}+A^2 = g_0^2 + A^2$;
then $f_0^4, f_0^8, f_0^{16}$. By repeating squaring we get a system of equations:
\begin{displaymath}
  \begin{cases}
  f_0  &=\ \  0\\
  f_0^2 & =\ \  0\\
  f_0^4  &=\ \  0\\
  f_0^8  &=\ \  0\\
  f_0^{16} & =\ \ 0
  \end{cases}
\Longleftrightarrow\ \
\begin{cases}
  g_0 & =\ \  A\\
  g_0^2 & =\ \  A^2\\
  g_0^4 & =\ \  A^4\\
  g_0^8 & =\ \  A^8\\
  g_0^{16} & =\ \  A^{16}
  \end{cases}
\end{displaymath}
Following is the coefficients matrix form of this system of equations:
\begin{displaymath}
\begin{pmatrix}
\alpha^5 & \alpha^{10} & \alpha^{20} & \alpha^9 & \alpha^{18} \\
\alpha^{10} & \alpha^{20} & \alpha^9 & \alpha^{18} & \alpha^5 \\
\alpha^{20} & \alpha^9 & \alpha^{18} & \alpha^5 & \alpha^{10} \\
\alpha^9 & \alpha^{18} & \alpha^5 & \alpha^{10} & \alpha^{20} \\
\alpha^{18} & \alpha^5 & \alpha^{10} & \alpha^{20} & \alpha^9 
\end{pmatrix}
\begin{pmatrix}
a_0\\
a_1\\
a_2\\
a_3\\
a_4
\end{pmatrix}
=
\begin{pmatrix}
A\\
A^2\\
A^4\\
A^8\\
A^{16}
\end{pmatrix}
\end{displaymath}

Use Gaussian elimination on coefficients matrix, for example  
\begin{align}
Row\ 2 =& Row\ 1\times \alpha^5 + Row\ 2: \nonumber\\
&a_1+(\alpha)a_2+(\alpha^4+\alpha^2)a_3+(\alpha^3+\alpha^2)a_4\nonumber\\
=&(\alpha^4+\alpha^3+\alpha^2+1)A^2+(\alpha^2+\alpha)A\nonumber
\end{align}
Recursively eliminate $a_1$ from third row, $a_2$ from fourth row, etc. The final solution to this system of
equations is
%\begin{displaymath}
%\{g_i\ | \ g_i: a_i + \mathcal{G}_i(A)\}
%\end{displaymath}
%\end{Example}
\begin{displaymath}
\left\{
  \begin{array}{lcl}
  a_0 & = & (\alpha+1)A^{16}+(\alpha^4+\alpha^3+\alpha)A^8+(\alpha^3+\alpha^2)A^4\\&&+(\alpha^4+1)A^2+(\alpha^2+1)A\\
  a_1 & = & (\alpha^2+1)A^{16}+(\alpha+1)A^8+(\alpha^4+\alpha^3+\alpha)A^4\\&&+(\alpha^3+\alpha^2)A^2+(\alpha^4+1)A\\
  a_2 & = & (\alpha^4+1)A^{16}+(\alpha^2+1)A^8+(\alpha+1)A^4\\&&+(\alpha^4+\alpha^3+\alpha)A^2+(\alpha^3+\alpha^2)A\\
  a_3 & = & (\alpha^3+\alpha^2)A^{16}+(\alpha^4+1)A^8+(\alpha^2+1)A^4\\&&+(\alpha+1)A^2+(\alpha^4+\alpha^3+\alpha)A\\
  a_4 & = & (\alpha^4+\alpha^3+\alpha)A^{16}+(\alpha^3+\alpha^2)A^8+(\alpha^4+1)A^4\\&&+(\alpha^2+1)A^2+(\alpha+1)A
  \end{array} \right.
\end{displaymath}
\end{Example}
Similarly we can compute equivalent polynomials $\mathcal{H}_i(R)$ for $r_i$, $\mathcal{T}_j(B)$ for $b_j$.
\textbf{(do we need a proof that remainder will only have $r_i,b_j$ here?)}

By replacing all bit-level variables by corresponding word-level variable polynomials, we transform the remainder
of $Spoly$ reduction to the form of $R'+R+\mathcal F'(A,B)$. Note $R$ is present state notion of output, which
equals to initial value $R=0$ in first clock cycle, or value of $R'$ from last clock cycle. By substituting
$R$ with its corresponding value ($0$ or a polynomial only about $A$ and $B$), we get the desired polynomial function
$R'+\mathcal F(A,B)$.
