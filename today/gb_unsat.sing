LIB "general.lib";
LIB "poly.lib";

proc my_spoly(poly f, poly g)
{
	poly M = lcm(leadmonom(f),leadmonom(g));
	poly S = M/lead(f)*f - M/lead(g)*g;
	return (S);
}

proc or2(poly f, poly g)
{
    return (f+g+f*g);
}

proc or3(poly f1, poly f2, poly f3)
{
    poly g = or2(f1,f2);
    g = or2(g,f3);
    return (g);
}

proc multidiv(poly f, ideal I)
{
	poly p = f;
	poly fi,r = 0,0;
	ideal J;
	int s = size(I);
	J[s] = 0;
	int i, divmark;
	while (lead(p) != 0)
	{
		i = 1;
		divmark = 0;
		while (i <= s and divmark == 0)
		{
			fi = I[i];
			if(lead(p)/lead(fi) != 0)
			{
				J[i] = J[i] + lead(p)/lead(fi);
				p = p - lead(p)/lead(fi)*fi;
				divmark = 1;
			}
			else
			{
				i = i+1;
			}
		}
		if (divmark == 0)
		{
			r = r + lead(p);
			p = p - lead(p);
		}
	}
	return (r);
}

proc multidiv_q(poly f, ideal I)
{
	poly p = f;
	poly fi,r = 0,0;
	ideal J;
	int s = size(I);
	J[s] = 0;
	int i, divmark;
	while (lead(p) != 0)
	{
		i = 1;
		divmark = 0;
		while (i <= s and divmark == 0)
		{
			fi = I[i];
			if(lead(p)/lead(fi) != 0)
			{
				J[i] = J[i] + lead(p)/lead(fi);
				p = p - lead(p)/lead(fi)*fi;
				divmark = 1;
			}
			else
			{
				i = i+1;
			}
		}
		if (divmark == 0)
		{
			r = r + lead(p);
			p = p - lead(p);
		}
	}
	return (r,J);
}

proc myGB(ideal F)
{
	ideal G = F;
	ideal G0;
	int s = size(F);
	int i;
	int j;
	int jj = 2;
	int jz = 2;
	int n = s;
	poly r;

	while(1)
	{
		G0 = G;
		n = size(G0);
//		"n=",n;
//		"jj=",jj;
//		if(jj>n) {"Error!";}
		jj = jz;
		for (i=1; i<n; i=i+1)
		{
		  if(i > (jz - 1))
		  {jj = i + 1;}
			for (j=jj; j<=n; j=j+1)
			{/* maybe should detect if i>j? */
//			  if(i >= j) {continue;}
//			  "report: (",i,",",j,")";
				r = my_spoly(G0[i], G0[j]);
				r = multidiv(r, G0);
				if (lead(r) != 0)
				{
					if(lead(r) == 1) {"Void!!!",s+1," from pair (",i,",",j,")";
					  "remainder =",r,", poly ",i," is",G0[i]," poly",j,"is ",G0[j];
					}
					else {"Add new",s+1," from pair (",i,",",j,")";}
					s = s+1;
					G[s] = r;
				}
			}
		}
		jz = n+1;
		if (size(G) == size(G0))
		{
			return (G);
		}
	}
}

proc miniGB(ideal G0)
{
	int s = size(G0);
	int i;
	int j;
	int k;
	for (i = 1; i <= s; i = i + 1)
	{
		for (j = 1; j <= s; j = j +1)
		{
			if (lead(G0[j]) != 0)
			{
				if (lead(G0[i])/lead(G0[j]) != 0 and i != j)
				{G0[i] = 0;}
			}
		}
	}
	ideal G = sort(G0)[1];
	s = size(G);
	for (k = 1; k <= s; k = k + 1)
	{
		G[k] = G[k]/leadcoef(G[k]);
	}
	return (G);
}

proc myRGB(ideal G0)
{
	int s = size(G0);
	poly h0;
	ideal q0,H;
	for (int i = 1; i <= s; i = i + 1)
	{
		ideal F = G0;
		F[i] = 0;
		H = sort(F)[1];
		h0,q0 = multidiv(G0[i],H);
		G0[i] = h0;
	}
	return (G0);
}

proc noduplicate(ideal I)
{
	int i;
	int s = size(I);
	ideal J;
	int j = 2;
	I = sort(I)[1];
	J[1] = I[1];
	for(i=2;i<=s;i=i+1)
	{
		if(I[i] != I[i-1])
		{J[j] = I[i]; j=j+1;}
	}
	return (J);
}

ring Q = 2, (x,b,y,a,z), lp;
ideal f = 1+or2(x,y),  1+or3(a,x,(1+z)), 1+or2((1+a),(1+b)), 1+or2(a,b), 1+or2((1+a),b), 1+or2(a,(1+b)), 1+or2(y,z), 1+or2(b,(1+y));
ideal va = a2+a, b2+b, x2+x, y2+y, z2+z;
//ideal f = x2y - y+x, xy2-x;
ideal G0 = myGB(f);
ideal mG = miniGB(G0);
//ideal G = myRGB(mG);
"Groebner Basis:";
G0;
"Minimum Groebner Basis:";
mG;
//"Reduced Groebner Basis:";
//G;
quit;
