#!/usr/bin/perl -w

use 5.014;
use strict;
use warnings;

open POLY, ">", "s953.sing";  # change the name
open TOPO, ">", "g953";
my $cnt = 0;

my $i;
my $tmp;
my $idx;

my @PI;
my @inputs;
my @outputs;
my @var;

print POLY "ideal I = ";

while(<>){
	chomp;
	my $read_in = $_;
	my @items = split /\s+/;
	$cnt++;
	if(!defined($items[0])) {next;}  # skip empty lines
	if($items[0] =~ /#/) {next;}  # skip comments
	if($read_in =~ /INPUT\(/){  # write vanishing polys based on inputs
	  $tmp = &abstract($read_in); # 'abstract' is to retract string in parenthesis
	  push @PI, $tmp;
	  push @var, $tmp;
	  next;
	}
	if($read_in =~ /OUTPUT\(/) {  # PO: only record for graph
	  $tmp = &abstract($read_in);
	  push @var, $tmp;
	  next;
	}
	if($read_in =~ /DFF\(/){  # record pseudo in/out, require space besides '=' 
	  $tmp = &abstract($items[2]);
	  push @inputs, $tmp;
	  push @outputs, $items[0];
	  push @var, $tmp;
	  push @var, $items[0];
	  next;
	}
	if($read_in =~ /NAND\(/){  # because 'NAND' contains 'AND', so take this first. Directly write poly
	  $tmp = &abstract($items[2]);
	  &write_nand($items[0],$tmp);
	  next;
	}
	if($read_in =~ /AND\(/){  # now comes to 'AND'
	  $tmp = &abstract($items[2]);
	  &write_and($items[0],$tmp);
	  next;
	}
	if($read_in =~ /NOR\(/){  # note possibly exceed the set bound for gate inputs, so pass the cnt to deal exception
	  $tmp = &abstract($items[2]);
	  &write_nor($items[0],$tmp,$cnt);
	  next;
	}
	if($read_in =~ /OR\(/){  # similar for OR gates
	  $tmp = &abstract($items[2]);
	  &write_or($items[0],$tmp,$cnt);
	  next;
	}
	if($read_in =~ /NOT\(/){  # NOT gate, directly write
	  $tmp = &abstract($items[2]);
	  print POLY "$items[0]+1+$tmp, ";
	  $idx = &query($items[0]);
	  print TOPO "$idx ";
	  $idx = &query($tmp);
	  print TOPO "$idx\n";
	  next;
	}
}
print POLY "\n";
for($i=0; $i<=$#PI;$i++)  # write vanishing poly for every input, include PIs and pseudo inputs
{
	print POLY "$PI[$i]^2+$PI[$i], ";
}
for($i=0; $i<=$#inputs;$i++) 
{
	print POLY "$inputs[$i]^2+$inputs[$i], ";
}
print POLY "\nS+$inputs[0]";  # word-level input
for($i=1; $i<=$#inputs;$i++) 
{
	print POLY "+X^$i*$inputs[$i]";
}
print POLY ", ";
print POLY "\nT+$outputs[0]";  # word-level output
for($i=1; $i<=$#outputs;$i++) 
{
	print POLY "+X^$i*$outputs[$i]";
}
print POLY "; ";
for($i=0;$i<=$#var;$i++)  # this line is for C++ toposort alg. to print the name of nodes rather than indices
{
  print TOPO "$var[$i] ";
}
print TOPO "\n# Remember to fill in the edge number then put following line at beginning, then delete this line\n";
$i = $#var+1;
print TOPO "$i ";

sub abstract{
  my $op = $_;
  my $n = index($op,"(");
  my $s = substr($op,$n+1,length($op)-$n-2);
  return($s);
}

sub query{
  my $target = $_[0];
  my %cvar;
  my $j = 0;
  map { $cvar{$_} = $j++ } @var;
  if (exists $cvar{$target})
  {
	return($cvar{$target});
  }
  else
  {
	push @var, $target;
	return($#var);
  }
}

sub write_nand{
  my $left = $_[0];
  my $right = $_[1];
  my @term = split /,\s/,$right;
  if(!defined($term[2]))  # which means this is 2-input NAND
  {
	print POLY "$left+1+$term[0]*$term[1], ";
	$idx = &query($left);
	print TOPO "$idx ";
	$idx = &query($term[0]);
	print TOPO "$idx\n";
	$idx = &query($left);  # repeat here, can improve
	print TOPO "$idx ";
	$idx = &query($term[1]);
	print TOPO "$idx\n";
  }
  else  # note: multi-input NAND
  {
	my $n = $#term + 1;
	$right = join "*", @term;
	print POLY "$left+1+$right, ";
	my $pos = &query($left);
	my $j;
	for($j=0;$j<$n;$j++){
	  $idx = &query($term[$j]);
	  print TOPO "$pos $idx\n";
	}
  }
}

sub write_and{  #copy from above; also for NOR and OR
  my $left = $_[0];
  my $right = $_[1];
  my @term = split /,\s/,$right;
  if(!defined($term[2]))  # which means this is 2-input AND
  {
	print POLY "$left+$term[0]*$term[1], ";
	$idx = &query($left);
	print TOPO "$idx ";
	$idx = &query($term[0]);
	print TOPO "$idx\n";
	$idx = &query($left);  # repeat here, can improve
	print TOPO "$idx ";
	$idx = &query($term[1]);
	print TOPO "$idx\n";
  }
  else  # note: multi-input AND
  {
	my $n = $#term + 1;
	$right = join "*", @term;
	print POLY "$left+$right, ";
	my $pos = &query($left);
	my $j;
	for($j=0;$j<$n;$j++){
	  $idx = &query($term[$j]);
	  print TOPO "$pos $idx\n";
	}
  }
}

sub write_nor{  # derive from NAND (add one argument)
  my $left = $_[0];
  my $right = $_[1];
  my $lines = $_[2];
  my @term = split /,\s/,$right;
  if(!defined($term[2]))  # which means this is 2-input NOR
  {
	print POLY "$left+1+or2($term[0],$term[1]), ";
	$idx = &query($left);
	print TOPO "$idx ";
	$idx = &query($term[0]);
	print TOPO "$idx\n";
	$idx = &query($left);  # repeat here, can improve
	print TOPO "$idx ";
	$idx = &query($term[1]);
	print TOPO "$idx\n";
  }
  else  # note: multi-input NOR
  {
	my $n = $#term + 1;
	if($n>5) {print "Warning: There is a multi-input gate exceeds bound of fanin, script may fail: Line $lines in bench file\n";}
	$right = join ",", @term;  # which can be skipped
	print POLY "$left+1+or$n($right), ";
	my $pos = &query($left);
	my $j;
	for($j=0;$j<$n;$j++){
	  $idx = &query($term[$j]);
	  print TOPO "$pos $idx\n";
	}
  }
}

sub write_or{  # derive from NOR
  my $left = $_[0];
  my $right = $_[1];
  my $lines = $_[2];
  my @term = split /,\s/,$right;
  if(!defined($term[2]))  # which means this is 2-input OR
  {
	print POLY "$left+or2($term[0],$term[1]), ";
	$idx = &query($left);
	print TOPO "$idx ";
	$idx = &query($term[0]);
	print TOPO "$idx\n";
	$idx = &query($left);  # repeat here, can improve
	print TOPO "$idx ";
	$idx = &query($term[1]);
	print TOPO "$idx\n";
  }
  else  # note: multi-input OR
  {
	my $n = $#term + 1;
	if($n>5) {print "Warning: There is a multi-input gate exceeds bound of fanin, script may fail: Line $lines in bench file\n";}
	$right = join ",", @term;  # which can be skipped
	print POLY "$left+or$n($right), ";
	my $pos = &query($left);
	my $j;
	for($j=0;$j<$n;$j++){
	  $idx = &query($term[$j]);
	  print TOPO "$pos $idx\n";
	}
  }
}